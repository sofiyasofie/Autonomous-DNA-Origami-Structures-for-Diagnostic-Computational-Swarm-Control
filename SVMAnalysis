{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "%matplotlib inline\n",
    "\n",
    "bankdata = pd.read_csv(\"/Users/sofielysenko/Desktop/sf2019.csv\") # Reading the data in with pandas\n",
    "#df1 = pd.read_csv(\"/Users/sofielysenko/images.csv\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(3660, 3)"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "bankdata.shape # rows, columns"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Catalyst</th>\n",
       "      <th>Input</th>\n",
       "      <th>Region</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>0.000000</td>\n",
       "      <td>0.300000</td>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>0.545587</td>\n",
       "      <td>0.377833</td>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>1.419165</td>\n",
       "      <td>0.799190</td>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>2.116442</td>\n",
       "      <td>1.144639</td>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>2.636345</td>\n",
       "      <td>1.294495</td>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   Catalyst     Input  Region\n",
       "0  0.000000  0.300000       2\n",
       "1  0.545587  0.377833       2\n",
       "2  1.419165  0.799190       2\n",
       "3  2.116442  1.144639       2\n",
       "4  2.636345  1.294495       2"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "bankdata.head() # see what data looks like"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Convert to a pickle file \n",
    "bankdata.to_pickle('normalized_all_keypoints.pickle')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Data Preprocessing\n",
    "#(1) Divide the data into attributes and labels\n",
    "#(2) Divide the data into training and testing sets"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "ename": "KeyError",
     "evalue": "'the label [Image] is not in the [columns]'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "\u001b[0;32m~/anaconda3/lib/python3.7/site-packages/pandas/core/indexing.py\u001b[0m in \u001b[0;36m_validate_key\u001b[0;34m(self, key, axis)\u001b[0m\n\u001b[1;32m   1789\u001b[0m                 \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0max\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcontains\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1790\u001b[0;31m                     \u001b[0merror\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1791\u001b[0m             \u001b[0;32mexcept\u001b[0m \u001b[0mTypeError\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0me\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/anaconda3/lib/python3.7/site-packages/pandas/core/indexing.py\u001b[0m in \u001b[0;36merror\u001b[0;34m()\u001b[0m\n\u001b[1;32m   1784\u001b[0m                                .format(key=key,\n\u001b[0;32m-> 1785\u001b[0;31m                                        axis=self.obj._get_axis_name(axis)))\n\u001b[0m\u001b[1;32m   1786\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mKeyError\u001b[0m: 'the label [Image] is not in the [columns]'",
      "\nDuring handling of the above exception, another exception occurred:\n",
      "\u001b[0;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-6-a0f9ebda1d39>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mdf\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mbankdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mloc\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m'Image'\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mvalues\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;32m~/anaconda3/lib/python3.7/site-packages/pandas/core/indexing.py\u001b[0m in \u001b[0;36m__getitem__\u001b[0;34m(self, key)\u001b[0m\n\u001b[1;32m   1470\u001b[0m             \u001b[0;32mexcept\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mKeyError\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mIndexError\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1471\u001b[0m                 \u001b[0;32mpass\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1472\u001b[0;31m             \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_getitem_tuple\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1473\u001b[0m         \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1474\u001b[0m             \u001b[0;31m# we by definition only have the 0th axis\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/anaconda3/lib/python3.7/site-packages/pandas/core/indexing.py\u001b[0m in \u001b[0;36m_getitem_tuple\u001b[0;34m(self, tup)\u001b[0m\n\u001b[1;32m    868\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0m_getitem_tuple\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtup\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    869\u001b[0m         \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 870\u001b[0;31m             \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_getitem_lowerdim\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtup\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    871\u001b[0m         \u001b[0;32mexcept\u001b[0m \u001b[0mIndexingError\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    872\u001b[0m             \u001b[0;32mpass\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/anaconda3/lib/python3.7/site-packages/pandas/core/indexing.py\u001b[0m in \u001b[0;36m_getitem_lowerdim\u001b[0;34m(self, tup)\u001b[0m\n\u001b[1;32m    996\u001b[0m         \u001b[0;32mfor\u001b[0m \u001b[0mi\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mkey\u001b[0m \u001b[0;32min\u001b[0m \u001b[0menumerate\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtup\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    997\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0mis_label_like\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mor\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtuple\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 998\u001b[0;31m                 \u001b[0msection\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_getitem_axis\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0maxis\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mi\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    999\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1000\u001b[0m                 \u001b[0;31m# we have yielded a scalar ?\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/anaconda3/lib/python3.7/site-packages/pandas/core/indexing.py\u001b[0m in \u001b[0;36m_getitem_axis\u001b[0;34m(self, key, axis)\u001b[0m\n\u001b[1;32m   1909\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1910\u001b[0m         \u001b[0;31m# fall thru to straight lookup\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1911\u001b[0;31m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_validate_key\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0maxis\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1912\u001b[0m         \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_get_label\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0maxis\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0maxis\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1913\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/anaconda3/lib/python3.7/site-packages/pandas/core/indexing.py\u001b[0m in \u001b[0;36m_validate_key\u001b[0;34m(self, key, axis)\u001b[0m\n\u001b[1;32m   1796\u001b[0m                 \u001b[0;32mraise\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1797\u001b[0m             \u001b[0;32mexcept\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1798\u001b[0;31m                 \u001b[0merror\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1799\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1800\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0m_is_scalar_access\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mkey\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/anaconda3/lib/python3.7/site-packages/pandas/core/indexing.py\u001b[0m in \u001b[0;36merror\u001b[0;34m()\u001b[0m\n\u001b[1;32m   1783\u001b[0m                 raise KeyError(u\"the label [{key}] is not in the [{axis}]\"\n\u001b[1;32m   1784\u001b[0m                                .format(key=key,\n\u001b[0;32m-> 1785\u001b[0;31m                                        axis=self.obj._get_axis_name(axis)))\n\u001b[0m\u001b[1;32m   1786\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1787\u001b[0m             \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mKeyError\u001b[0m: 'the label [Image] is not in the [columns]'"
     ]
    }
   ],
   "source": [
    "df = bankdata.loc[:,'Image'].values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import csv\n",
    "csvfile = \"labels.csv\"   \n",
    "with open(csvfile, \"a\") as fp:\n",
    "    wr = csv.writer(fp, dialect='excel')\n",
    "    res=[]\n",
    "    \n",
    "    for a in df1:\n",
    "        res.append(a)\n",
    "        wr.writerow(res)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = bankdata.loc[:,'y'].values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import csv\n",
    "csvfile = \"y_pose2.csv\"   \n",
    "with open(csvfile, \"a\") as fp:\n",
    "    wr = csv.writer(fp, dialect='excel')\n",
    "    res=[]\n",
    "    count_ele=0\n",
    "    for a in df:\n",
    "        res.append(a)\n",
    "        count_ele+=1\n",
    "        if count_ele > 17:\n",
    "            wr.writerow(res)\n",
    "            count_ele=0\n",
    "            res=[]\n",
    "\n",
    "#test68y_1 and test68x_1 are the two used"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "   \n",
    "res=[]\n",
    "for a in df:\n",
    "    res.append(a)\n",
    "    \n",
    "from collections import OrderedDict\n",
    "res1 = list(OrderedDict.fromkeys(res))\n",
    "\n",
    "import csv\n",
    "csvfile = \"labels1.csv\"   \n",
    "with open(csvfile, \"a\") as fp:\n",
    "    wr = csv.writer(fp, dialect='excel')\n",
    "    wr.writerow(res1)\n",
    "    res=[]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "X = bankdata.drop('Region', axis=1)# removing the Class column bc that is labels\n",
    "y = bankdata['Region'] # only Class column"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "X = bankdata.drop('Region', axis=1)# removing the Class column bc that is labels\n",
    "y = bankdata['Region'] # only Class column"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.model_selection import train_test_split  # split into testing and training sets\n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.33, random_state=0, stratify=y)  \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "ename": "ImportError",
     "evalue": "cannot import name 'cross_validation' from 'sklearn' (/Users/sofielysenko/anaconda3/lib/python3.7/site-packages/sklearn/__init__.py)",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mImportError\u001b[0m                               Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-7-ae423d8f2827>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0;32mfrom\u001b[0m \u001b[0msklearn\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mcross_validation\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      2\u001b[0m X_train, X_test, y_train, y_test = cross_validation.train_test_split(X,\n\u001b[1;32m      3\u001b[0m                                                     y, test_size=0.66)\n",
      "\u001b[0;31mImportError\u001b[0m: cannot import name 'cross_validation' from 'sklearn' (/Users/sofielysenko/anaconda3/lib/python3.7/site-packages/sklearn/__init__.py)"
     ]
    }
   ],
   "source": [
    "from sklearn import cross_validation\n",
    "X_train, X_test, y_train, y_test = cross_validation.train_test_split(X,\n",
    "                                                    y, test_size=0.66)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Train: [   0    1    2 ... 3657 3658 3659] Validation: [  19   25   62  164  202  308  363  467  509  528  543  568  574  686\n",
      "  793  812  825  847 1007 1066 1106 1153 1460 1531 1554 1566 1575 1600\n",
      " 1614 1764 1848 2129 2170 2197 2198 2260 2434 2485 2693 2772 2795 2821\n",
      " 2849 2972 3052 3076 3083 3179 3184 3228 3299 3542 3587]\n"
     ]
    },
    {
     "ename": "KeyError",
     "evalue": "'[   0    1    2 ... 3657 3658 3659] not in index'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-8-5400298953eb>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m      5\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mtrain_index\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtest_index\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mkf\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msplit\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      6\u001b[0m       \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"Train:\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtrain_index\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"Validation:\"\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mtest_index\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 7\u001b[0;31m       \u001b[0mX_train\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mX_test\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mX\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mtrain_index\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mX\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mtest_index\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      8\u001b[0m       \u001b[0my_train\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my_test\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0my\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mtrain_index\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mtest_index\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/anaconda3/lib/python3.7/site-packages/pandas/core/frame.py\u001b[0m in \u001b[0;36m__getitem__\u001b[0;34m(self, key)\u001b[0m\n\u001b[1;32m   2680\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mSeries\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mndarray\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mIndex\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mlist\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   2681\u001b[0m             \u001b[0;31m# either boolean or fancy integer index\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 2682\u001b[0;31m             \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_getitem_array\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   2683\u001b[0m         \u001b[0;32melif\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mDataFrame\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   2684\u001b[0m             \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_getitem_frame\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/anaconda3/lib/python3.7/site-packages/pandas/core/frame.py\u001b[0m in \u001b[0;36m_getitem_array\u001b[0;34m(self, key)\u001b[0m\n\u001b[1;32m   2724\u001b[0m             \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_take\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mindexer\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0maxis\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   2725\u001b[0m         \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 2726\u001b[0;31m             \u001b[0mindexer\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mloc\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_convert_to_indexer\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0maxis\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   2727\u001b[0m             \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_take\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mindexer\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0maxis\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   2728\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/anaconda3/lib/python3.7/site-packages/pandas/core/indexing.py\u001b[0m in \u001b[0;36m_convert_to_indexer\u001b[0;34m(self, obj, axis, is_setter)\u001b[0m\n\u001b[1;32m   1325\u001b[0m                 \u001b[0;32mif\u001b[0m \u001b[0mmask\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0many\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1326\u001b[0m                     raise KeyError('{mask} not in index'\n\u001b[0;32m-> 1327\u001b[0;31m                                    .format(mask=objarr[mask]))\n\u001b[0m\u001b[1;32m   1328\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1329\u001b[0m                 \u001b[0;32mreturn\u001b[0m \u001b[0mcom\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_values_from_object\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mindexer\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mKeyError\u001b[0m: '[   0    1    2 ... 3657 3658 3659] not in index'"
     ]
    }
   ],
   "source": [
    "from sklearn.model_selection import RepeatedKFold \n",
    "\n",
    "kf = RepeatedKFold(n_splits=70, n_repeats=50, random_state=None) \n",
    "\n",
    "for train_index, test_index in kf.split(X):\n",
    "      print(\"Train:\", train_index, \"Validation:\",test_index)\n",
    "      X_train, X_test = X[train_index], X[test_index] \n",
    "      y_train, y_test = y[train_index], y[test_index]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0,\n",
       "  decision_function_shape='ovr', degree=3, gamma='auto_deprecated',\n",
       "  kernel='linear', max_iter=-1, probability=False, random_state=None,\n",
       "  shrinking=True, tol=0.001, verbose=False)"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Training the Algo\n",
    "\n",
    "from sklearn.svm import SVC  \n",
    "svclassifier = SVC(kernel='linear')\n",
    "svclassifier.fit(X_train, y_train)  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Making Predictions\n",
    "y_pred = svclassifier.predict(X_test)  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[  1   0   1   0 239]\n",
      " [  3   0   1   0 238]\n",
      " [  3   0   0   0 238]\n",
      " [  4   0   0   0 238]\n",
      " [  4   0   2   0 236]]\n",
      "              precision    recall  f1-score   support\n",
      "\n",
      "           1       0.07      0.00      0.01       241\n",
      "           2       0.00      0.00      0.00       242\n",
      "           3       0.00      0.00      0.00       241\n",
      "           4       0.00      0.00      0.00       242\n",
      "           5       0.20      0.98      0.33       242\n",
      "\n",
      "   micro avg       0.20      0.20      0.20      1208\n",
      "   macro avg       0.05      0.20      0.07      1208\n",
      "weighted avg       0.05      0.20      0.07      1208\n",
      "\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/sofielysenko/anaconda3/lib/python3.7/site-packages/sklearn/metrics/classification.py:1143: UndefinedMetricWarning: Precision and F-score are ill-defined and being set to 0.0 in labels with no predicted samples.\n",
      "  'precision', 'predicted', average, warn_for)\n"
     ]
    }
   ],
   "source": [
    "#Evaluating the Algo\n",
    "#Confusion matrix, precision, recall, and F1 measures are the most commonly used metrics for classification tasks\n",
    "from sklearn.metrics import classification_report, confusion_matrix  \n",
    "print(confusion_matrix(y_test,y_pred))  \n",
    "print(classification_report(y_test,y_pred))  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Implementing Kernel SVM with Scikit-Learn"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np  \n",
    "import matplotlib.pyplot as plt  \n",
    "import pandas as pd  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "%matplotlib inline\n",
    "\n",
    "bankdata = pd.read_csv(\"/Users/sofielysenko/Desktop/sf2019.csv\") # Reading the data in with pandas"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "X = bankdata.drop('Region', axis=1) # removing the Class column bc that is labels\n",
    "y = bankdata['Region'] # only Class column"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Train Test Split\n",
    "from sklearn.model_selection import train_test_split  \n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.33)  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/sofielysenko/anaconda3/lib/python3.7/site-packages/sklearn/svm/base.py:196: FutureWarning: The default value of gamma will change from 'auto' to 'scale' in version 0.22 to account better for unscaled features. Set gamma explicitly to 'auto' or 'scale' to avoid this warning.\n",
      "  \"avoid this warning.\", FutureWarning)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[242   1   1   1   0]\n",
      " [235   1   4   0   3]\n",
      " [238   0   0   1   0]\n",
      " [240   2   0   0   1]\n",
      " [234   1   2   1   0]]\n",
      "              precision    recall  f1-score   support\n",
      "\n",
      "           1       0.20      0.99      0.34       245\n",
      "           2       0.20      0.00      0.01       243\n",
      "           3       0.00      0.00      0.00       239\n",
      "           4       0.00      0.00      0.00       243\n",
      "           5       0.00      0.00      0.00       238\n",
      "\n",
      "   micro avg       0.20      0.20      0.20      1208\n",
      "   macro avg       0.08      0.20      0.07      1208\n",
      "weighted avg       0.08      0.20      0.07      1208\n",
      "\n"
     ]
    }
   ],
   "source": [
    "#1. Polynomial Kernel\n",
    "\n",
    "from sklearn.svm import SVC  \n",
    "svclassifier = SVC(kernel='poly', degree=10)  \n",
    "svclassifier.fit(X_train, y_train)  \n",
    "\n",
    "#Making predictions\n",
    "y_pred = svclassifier.predict(X_test)  \n",
    "\n",
    "#Evaluate \n",
    "from sklearn.metrics import classification_report, confusion_matrix  \n",
    "print(confusion_matrix(y_test, y_pred))  \n",
    "print(classification_report(y_test, y_pred))  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/sofielysenko/anaconda3/lib/python3.7/site-packages/sklearn/svm/base.py:196: FutureWarning: The default value of gamma will change from 'auto' to 'scale' in version 0.22 to account better for unscaled features. Set gamma explicitly to 'auto' or 'scale' to avoid this warning.\n",
      "  \"avoid this warning.\", FutureWarning)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[  0   0   1   0 244]\n",
      " [  0   0   1   2 240]\n",
      " [  1   0   0   0 238]\n",
      " [  0   0   2   0 241]\n",
      " [  0   0   2   0 236]]\n",
      "              precision    recall  f1-score   support\n",
      "\n",
      "           1       0.00      0.00      0.00       245\n",
      "           2       0.00      0.00      0.00       243\n",
      "           3       0.00      0.00      0.00       239\n",
      "           4       0.00      0.00      0.00       243\n",
      "           5       0.20      0.99      0.33       238\n",
      "\n",
      "   micro avg       0.20      0.20      0.20      1208\n",
      "   macro avg       0.04      0.20      0.07      1208\n",
      "weighted avg       0.04      0.20      0.06      1208\n",
      "\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/sofielysenko/anaconda3/lib/python3.7/site-packages/sklearn/metrics/classification.py:1143: UndefinedMetricWarning: Precision and F-score are ill-defined and being set to 0.0 in labels with no predicted samples.\n",
      "  'precision', 'predicted', average, warn_for)\n"
     ]
    }
   ],
   "source": [
    "#2. Gaussian Kernel\n",
    "#(different setup)\n",
    "from sklearn.svm import SVC  \n",
    "svclassifier = SVC(kernel='rbf')  \n",
    "svclassifier.fit(X_train, y_train)  \n",
    "\n",
    "#Prediction (same)\n",
    "y_pred = svclassifier.predict(X_test)  \n",
    "\n",
    "#Evaluate (same)\n",
    "from sklearn.metrics import classification_report, confusion_matrix  \n",
    "print(confusion_matrix(y_test, y_pred))  \n",
    "print(classification_report(y_test, y_pred))  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/sofielysenko/anaconda3/lib/python3.7/site-packages/sklearn/svm/base.py:196: FutureWarning: The default value of gamma will change from 'auto' to 'scale' in version 0.22 to account better for unscaled features. Set gamma explicitly to 'auto' or 'scale' to avoid this warning.\n",
      "  \"avoid this warning.\", FutureWarning)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[  0   0   0   0 245]\n",
      " [  0   0   0   0 243]\n",
      " [  0   0   0   0 239]\n",
      " [  0   0   0   0 243]\n",
      " [  0   0   0   0 238]]\n",
      "              precision    recall  f1-score   support\n",
      "\n",
      "           1       0.00      0.00      0.00       245\n",
      "           2       0.00      0.00      0.00       243\n",
      "           3       0.00      0.00      0.00       239\n",
      "           4       0.00      0.00      0.00       243\n",
      "           5       0.20      1.00      0.33       238\n",
      "\n",
      "   micro avg       0.20      0.20      0.20      1208\n",
      "   macro avg       0.04      0.20      0.07      1208\n",
      "weighted avg       0.04      0.20      0.06      1208\n",
      "\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/sofielysenko/anaconda3/lib/python3.7/site-packages/sklearn/metrics/classification.py:1143: UndefinedMetricWarning: Precision and F-score are ill-defined and being set to 0.0 in labels with no predicted samples.\n",
      "  'precision', 'predicted', average, warn_for)\n"
     ]
    }
   ],
   "source": [
    "#3. Sigmoid Kernel\n",
    "from sklearn.svm import SVC  \n",
    "svclassifier = SVC(kernel='sigmoid')  \n",
    "svclassifier.fit(X_train, y_train)  \n",
    "\n",
    "y_pred = svclassifier.predict(X_test)  \n",
    "\n",
    "from sklearn.metrics import classification_report, confusion_matrix  \n",
    "print(confusion_matrix(y_test, y_pred))  \n",
    "print(classification_report(y_test, y_pred))  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## If we compare the performance of the different types of kernels we can clearly see that the sigmoid kernel performs the worst. This is due to the reason that sigmoid function returns two values, 0 and 1, therefore it is more suitable for binary classification problems. However, in our case we had three output classes"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Amongst the Gaussian kernel and polynomial kernel, we can see that Gaussian kernel achieved a perfect 100% prediction rate while polynomial kernel misclassified one instance. Therefore the Gaussian kernel performed slightly better. However, there is no hard and fast rule as to which kernel performs best in every scenario. It is all about testing all the kernels and selecting the one with the best results on your test dataset."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "\n",
    "plt.plot([1,2,3,4], [1,2,3,4])\n",
    "plt.ylabel('some numbers')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "%matplotlib inline\n",
    "\n",
    "\n",
    "bankdata = pd.read_csv(\"/Users/sofielysenko/Desktop/18_1NTB_POS.csv\") # Reading the data in with pandas\n",
    "bankdata1 = pd.read_csv(\"/Users/sofielysenko/Desktop/20_1NTB_NEG.csv\") # Reading the data in with pandas\n",
    "bankdata2 = pd.read_csv(\"/Users/sofielysenko/Desktop/18_1NTB_NEU.csv\") # Reading the data in with pandas\n",
    "\n",
    "\n",
    "\n",
    "plt.plot(bankdata['x'],bankdata['y'], 'yo', label = 'Positive')\n",
    "plt.legend()\n",
    "plt.plot(bankdata1['x'],bankdata1['y'], 'bo', label = 'Negative')\n",
    "plt.legend()\n",
    "plt.plot(bankdata2['x'],bankdata2['y'], 'go', label = 'Neutral')\n",
    "plt.legend()\n",
    "plt.title('Infant 18/20 Session 1 NTB', fontsize = 15)\n",
    "\n",
    "plt.ylabel('y centroid')\n",
    "plt.xlabel('x centroid')\n",
    "plt.show()\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "%matplotlib inline\n",
    "\n",
    "\n",
    "bankdata = pd.read_csv(\"/Users/sofielysenko/Desktop/v_both_neg.csv\") # Reading the data in with pandas\n",
    "bankdata1 = pd.read_csv(\"/Users/sofielysenko/Desktop/v_both_pos.csv\") # Reading the data in with pandas\n",
    "#bankdata2 = pd.read_csv(\"/Users/sofielysenko/Desktop/18_1NTB_NEU.csv\") # Reading the data in with pandas\n",
    "\n",
    "\n",
    "offset = lambda p: transforms.ScaledTranslation(p/72.,0, plt.gcf().dpi_scale_trans)\n",
    "trans = plt.gca().transData\n",
    "\n",
    "\n",
    "# plt.plot(bankdata['x'], bankdata['y'], 'yo', label = 'Negative')\n",
    "# plt.legend()\n",
    "plt.plot(bankdata1['x'], bankdata1['y'], 'bo', label = 'Positive')\n",
    "plt.legend()\n",
    "plt.title('Infant 18/20 1 NTB Velocity', fontsize = 15)\n",
    "\n",
    "#plt.ylabel('y centroid')\n",
    "#plt.xlabel('x centroid')\n",
    "plt.show()\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt  #plotting cross validation and emotion paramaters\n",
    "\n",
    "\n",
    "\n",
    "#mean curvature of eyes_top v. curvature of mouth_top\n",
    "\n",
    "plt.plot([-0.00806411,\n",
    "-0.01589476,\n",
    "-0.01160663,\n",
    "-0.01025176,\n",
    "-0.00311819,\n",
    "-0.00311819,\n",
    "-0.01160663,\n",
    "-0.01025176,\n",
    "-0.00311819,\n",
    "-0.01342401,\n",
    "-0.00908403,\n",
    "-0.01770433,\n",
    "-0.00675553,\n",
    "-0.00494765,\n",
    "-0.00463582,\n",
    "-0.0084853,\n",
    "-0.01111215,\n",
    "-0.01383382,\n",
    "-0.01378833,\n",
    "-0.00742621,\n",
    "-0.01065938,\n",
    "-0.01170681,\n",
    "-0.01170681,\n",
    "-0.00968592,\n",
    "-0.00479239,\n",
    "-0.01053609,\n",
    "-0.01676623,\n",
    "-0.00649448,\n",
    "-0.04080943,\n",
    "-0.01543992,\n",
    "-0.00734975,\n",
    "-0.0101308,\n",
    "-0.01101356,\n",
    "-0.01205509,\n",
    "-0.01656136,\n",
    "-0.01324697,\n",
    "-0.00848422,\n",
    "-0.01089667,\n",
    "-0.0067849,\n",
    "-0.01067126,\n",
    "-0.02367693,\n",
    "-0.00886555,\n",
    "-0.0215474,\n",
    "-0.02224071,\n",
    "-0.02224071,\n",
    "-0.0042364,\n",
    "-0.00368749,\n",
    "-0.00368749,\n",
    "-0.01282005,\n",
    "-0.01327951,\n",
    "-0.0110624,\n",
    "-0.0117359,\n",
    "-0.00724189,\n",
    "-0.01134828,\n",
    "-0.01935585,\n",
    "-0.00958579,\n",
    "-0.00985592,\n",
    "-0.01638157,\n",
    "-0.00764207,\n",
    "-0.00764207,\n",
    "-0.06870794], [-0.006518755,\n",
    "-0.008877615,\n",
    "-0.00761043,\n",
    "-0.00824203,\n",
    "-0.00674816,\n",
    "-0.00674816,\n",
    "-0.00761043,\n",
    "-0.00824203,\n",
    "-0.00674816,\n",
    "-0.001993585,\n",
    "-0.00858066,\n",
    "-0.009377765,\n",
    "-0.00280986,\n",
    "-0.009249925,\n",
    "-0.00035805,\n",
    "-0.001266414772,\n",
    "-0.014741315,\n",
    "-0.011204745,\n",
    "-0.006600885,\n",
    "-0.00419438,\n",
    "-0.006411365,\n",
    "-0.00878944,\n",
    "-0.00878944,\n",
    "-0.00773097,\n",
    "-0.010713985,\n",
    "-0.003269275,\n",
    "-0.008438265,\n",
    "-0.00900733,\n",
    "-0.016694445,\n",
    "-0.0080187,\n",
    "-0.005314275,\n",
    "-0.00925217,\n",
    "-0.004141405,\n",
    "-0.01187232,\n",
    "-0.007665355,\n",
    "-0.00942107,\n",
    "-0.004023245,\n",
    "-0.005430415,\n",
    "-0.00682665,\n",
    "-0.00827142,\n",
    "-0.009423155,\n",
    "-0.005675285,\n",
    "-0.011282435,\n",
    "-0.01351077,\n",
    "-0.01351077,\n",
    "-0.00843225,\n",
    "-0.00746669,\n",
    "-0.00746669,\n",
    "-0.00486183,\n",
    "-0.01017229,\n",
    "-0.00377968,\n",
    "-0.004918515,\n",
    "-0.007296505,\n",
    "-0.00551844,\n",
    "-0.006274305,\n",
    "-0.00197358,\n",
    "-0.01148569,\n",
    "-0.004669195,\n",
    "-0.01005287,\n",
    "-0.01005287,\n",
    "-0.06666667,\n",
    "\n",
    "], \"yo\", label = \"Positive\") #Positive\n",
    "plt.legend()\n",
    "\n",
    "plt.plot([-0.00632528,\n",
    "-0.01054894,\n",
    "-0.01054894,\n",
    "-0.01054894,\n",
    "-0.01054894,\n",
    "-0.01210659,\n",
    "-0.01210659,\n",
    "-0.00920739,\n",
    "-0.00390145,\n",
    "-0.01050513,\n",
    "-0.0103832,\n",
    "-0.01209897,\n",
    "-0.01209897,\n",
    "-0.0161115,\n",
    "-0.0161115,\n",
    "-0.00764177,\n",
    "-0.01514055,\n",
    "-0.00950656,\n",
    "-0.01000238,\n",
    "-0.01000238,\n",
    "-0.00737922,\n",
    "-0.00673623,\n",
    "-0.00673623,\n",
    "-0.01477629,\n",
    "-0.00087657,\n",
    "-0.00087657,\n",
    "-0.01451691,\n",
    "-0.01451691,\n",
    "-0.00868048,\n",
    "-0.00196974,\n",
    "-0.00726705,\n",
    "-0.02149493,\n",
    "-0.00569533,\n",
    "-0.00394741,\n",
    "-0.03413358,\n",
    "-0.01490169,\n",
    "-0.00659931,\n",
    "-0.00761598,\n",
    "-0.01379964,\n",
    "-0.00224749,\n",
    "-0.00266443,\n",
    "-0.01733787,\n",
    "-0.00911591,\n",
    "-0.0073498,\n",
    "-0.01425589,\n",
    "-0.01536487,\n",
    "-0.01113472,\n",
    "-0.00589383,\n",
    "-0.00968274], [-0.007562615,\n",
    "-0.00668079,\n",
    "-0.00668079,\n",
    "-0.00668079,\n",
    "-0.00668079,\n",
    "-0.00258631,\n",
    "-0.00258631,\n",
    "0.001263959811,\n",
    "-0.003569145,\n",
    "-0.002406855,\n",
    "-0.00257888,\n",
    "-0.00388262,\n",
    "-0.00388262,\n",
    "-0.00905484,\n",
    "-0.00905484,\n",
    "-0.004097115,\n",
    "-0.00300311,\n",
    "-0.009022355,\n",
    "-0.00332557,\n",
    "-0.00332557,\n",
    "-0.006944945,\n",
    "-0.00637214,\n",
    "-0.00637214,\n",
    "-0.011252155,\n",
    "-0.00647785,\n",
    "-0.00647785,\n",
    "-0.00342047,\n",
    "-0.00342047,\n",
    "-0.005677565,\n",
    "-0.004601335,\n",
    "-0.00258945,\n",
    "-0.01083616,\n",
    "-0.0145334,\n",
    "-0.002535885,\n",
    "-0.03618197,\n",
    "-0.002529885,\n",
    "-0.00531771,\n",
    "-0.0029355,\n",
    "-0.00365497,\n",
    "-0.01050821,\n",
    "-0.008622125,\n",
    "-0.00654587,\n",
    "-0.001391485,\n",
    "3.15E-04,\n",
    "0.0026387,\n",
    "-0.00437962,\n",
    "0.00036859,\n",
    "-0.008451715,\n",
    "-0.000477675],\"bo\", label= 'Negative') #Negative\n",
    "plt.legend()\n",
    "\n",
    "plt.plot([-0.0090756,\n",
    "-0.00735513,\n",
    "-0.01974855,\n",
    "-0.01347077,\n",
    "-0.00998419,\n",
    "-0.00389741,\n",
    "-0.0195448,\n",
    "-0.05693324,\n",
    "-0.0066998,\n",
    "-0.0126551,\n",
    "-0.00720337,\n",
    "-0.00720337,\n",
    "-0.00658918,\n",
    "-0.00924476,\n",
    "-0.01398233,\n",
    "-0.00524069,\n",
    "-0.01619646,\n",
    "-0.02141228,\n",
    "-0.01269043,\n",
    "-0.00617308,\n",
    "-0.0128979,\n",
    "-0.01256407,\n",
    "-0.02038972,\n",
    "-0.00615366,\n",
    "-0.01318539,\n",
    "-0.01689665,\n",
    "-0.00289739,\n",
    "-0.01394908,\n",
    "-0.00711871,\n",
    "-0.00727892,\n",
    "-0.00251227,\n",
    "-0.02010163,\n",
    "-0.00775365,\n",
    "-0.00735879,\n",
    "-0.00699078,\n",
    "-0.00703828], [-0.01346618,\n",
    "-0.00909097,\n",
    "-0.04674755,\n",
    "-0.010857525,\n",
    "-0.01695174,\n",
    "-0.010727625,\n",
    "-0.015819455,\n",
    "-0.0459596,\n",
    "-0.011195145,\n",
    "-0.015553535,\n",
    "-0.0098414,\n",
    "-0.0098414,\n",
    "-0.008742785,\n",
    "-0.0182225,\n",
    "-0.01125608,\n",
    "-0.011157715,\n",
    "-0.0131913,\n",
    "-0.02028265,\n",
    "-0.0117589,\n",
    "-0.01003293,\n",
    "-0.015322425,\n",
    "-0.011171765,\n",
    "-0.01797139,\n",
    "-0.01074623,\n",
    "-0.01311073,\n",
    "-0.02705113,\n",
    "-0.014152505,\n",
    "-0.013876535,\n",
    "-0.014175015,\n",
    "-0.011316025,\n",
    "-0.020318135,\n",
    "-0.014774325,\n",
    "-0.008984615,\n",
    "-0.01370141,\n",
    "-0.005908525,\n",
    "-0.01240508],\"ro\", label= 'Neutral') #Neutral\n",
    " #Neutral\n",
    "plt.legend()\n",
    "\n",
    "plt.ylabel('mean curvature of eyes_top')\n",
    "plt.xlabel('curvature of mouth_top')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt  #plotting cross validation and emotion paramaters\n",
    "\n",
    "\n",
    "\n",
    "#mean curvature of eyes_bottom v. curvature of mouth_bottom\n",
    "\n",
    "plt.plot([-0.00053172,\n",
    "0.00179896,\n",
    "-0.00082625,\n",
    "0.00163851,\n",
    "0.00554361,\n",
    "0.00554361,\n",
    "-0.00082625,\n",
    "0.00163851,\n",
    "0.00554361,\n",
    "0.00714897,\n",
    "0.00112689,\n",
    "0.01096554,\n",
    "0.00068501,\n",
    "0.00031863,\n",
    "0.00436679,\n",
    "0.00316389,\n",
    "0.00280791,\n",
    "0.00740591,\n",
    "0.00181211,\n",
    "0.00425187,\n",
    "0.00258992,\n",
    "0.00716907,\n",
    "0.00716907,\n",
    "0.00239199,\n",
    "0.00076099,\n",
    "0.0080315,\n",
    "0.00444299,\n",
    "0.00029762,\n",
    "0.01693755,\n",
    "0.00181862,\n",
    "0.0044141,\n",
    "0.00235529,\n",
    "0.00315402,\n",
    "0.00259624,\n",
    "0.00325328,\n",
    "0.00160456,\n",
    "0.00983083,\n",
    "0.00391261,\n",
    "0.00545945,\n",
    "-0.00027151,\n",
    "0.01007778,\n",
    "0.00910477,\n",
    "0.00262512,\n",
    "0.00909874,\n",
    "0.00909874,\n",
    "0.00286524,\n",
    "0.00231539,\n",
    "0.00231539,\n",
    "0.0071696,\n",
    "0.00365748,\n",
    "0.00623947,\n",
    "0.00400905,\n",
    "0.00403155,\n",
    "0.00385098,\n",
    "0.01026872,\n",
    "0.00340949,\n",
    "0.00214095,\n",
    "0.01193692,\n",
    "0.00409735,\n",
    "0.00409735,\n",
    "0.06443319], [0.01651621,\n",
    "0.00888925,\n",
    "0.01219278,\n",
    "0.02247927,\n",
    "0.01235369,\n",
    "0.01235369,\n",
    "0.01219278,\n",
    "0.02247927,\n",
    "0.01235369,\n",
    "0.01227882,\n",
    "0.01719957,\n",
    "0.02955061,\n",
    "0.01024655,\n",
    "0.01526611,\n",
    "0.02113394,\n",
    "0.00753002,\n",
    "0.02125608,\n",
    "0.02737288,\n",
    "0.01647447,\n",
    "0.00825593,\n",
    "0.00976881,\n",
    "0.01949738,\n",
    "0.01949738,\n",
    "0.01990381,\n",
    "0.02273756,\n",
    "0.01891317,\n",
    "0.01888252,\n",
    "0.01418944,\n",
    "0.03686995,\n",
    "0.01546764,\n",
    "0.00532303,\n",
    "0.01916671,\n",
    "0.01851596,\n",
    "0.02282631,\n",
    "0.02179928,\n",
    "0.02100884,\n",
    "0.00976369,\n",
    "0.0106125,\n",
    "0.01907229,\n",
    "0.02216865,\n",
    "0.02968961,\n",
    "0.02164486,\n",
    "0.02187902,\n",
    "0.02102634,\n",
    "0.02102634,\n",
    "0.01648939,\n",
    "0.02287401,\n",
    "0.02287401,\n",
    "0.02581778,\n",
    "0.0147891,\n",
    "0.01141587,\n",
    "0.01653191,\n",
    "0.01989948,\n",
    "0.01388858,\n",
    "0.01531977,\n",
    "0.01025967,\n",
    "0.01448538,\n",
    "0.01995541,\n",
    "0.02475113,\n",
    "0.02475113,\n",
    "0.14545455\n",
    "\n",
    "], \"yo\", label = \"Positive\") #Positive\n",
    "plt.legend()\n",
    "\n",
    "plt.plot([0.0035199,\n",
    "0.00019925,\n",
    "0.00019925,\n",
    "0.00019925,\n",
    "0.00019925,\n",
    "0.00563954,\n",
    "0.00563954,\n",
    "0.02133023,\n",
    "0.00200668,\n",
    "0.0112916,\n",
    "0.00874845,\n",
    "0.00094073,\n",
    "0.00094073,\n",
    "0.00441194,\n",
    "0.00441194,\n",
    "0.01159923,\n",
    "0.01100213,\n",
    "0.01093919,\n",
    "0.01273862,\n",
    "0.01273862,\n",
    "0.00099057,\n",
    "0.00335781,\n",
    "0.00335781,\n",
    "0.00684592,\n",
    "0.00761256,\n",
    "0.00761256,\n",
    "0.00201115,\n",
    "0.00201115,\n",
    "0.00260739,\n",
    "0.00357567,\n",
    "0.00231731,\n",
    "0.00238486,\n",
    "0.00906441,\n",
    "0.01161257,\n",
    "0.02371649,\n",
    "0.00883959,\n",
    "0.0035829,\n",
    "0.00190015,\n",
    "0.00557099,\n",
    "0.00878245,\n",
    "0.01091829,\n",
    "0.01499047,\n",
    "0.00422495,\n",
    "0.00562965,\n",
    "0.01646773,\n",
    "0.00813067,\n",
    "0.00877985,\n",
    "0.01025773,\n",
    "0.00710254], [0.01348223,\n",
    "0.01166671,\n",
    "0.01166671,\n",
    "0.01166671,\n",
    "0.01166671,\n",
    "0.011252,\n",
    "0.011252,\n",
    "0.0151846,\n",
    "0.008199,\n",
    "0.01180907,\n",
    "0.00767813,\n",
    "0.00010742,\n",
    "0.00010742,\n",
    "0.01281387,\n",
    "0.01281387,\n",
    "0.01184374,\n",
    "0.01624843,\n",
    "0.01722167,\n",
    "0.02053789,\n",
    "0.02053789,\n",
    "0.01675299,\n",
    "0.00261429,\n",
    "0.00261429,\n",
    "0.00985207,\n",
    "0.0088177,\n",
    "0.0088177,\n",
    "0.01183881,\n",
    "0.01183881,\n",
    "0.01268062,\n",
    "0.01246038,\n",
    "0.00746359,\n",
    "0.00058814,\n",
    "0.01482486,\n",
    "0.01972628,\n",
    "0.03875902,\n",
    "0.01256725,\n",
    "0.01307099,\n",
    "0.00738714,\n",
    "0.0025283,\n",
    "0.0131696,\n",
    "0.01478015,\n",
    "0.02454557,\n",
    "0.01065764,\n",
    "0.00769822,\n",
    "0.01248309,\n",
    "0.00453726,\n",
    "0.00759232,\n",
    "0.03311376,\n",
    "0.00533788],\"bo\", label= 'Negative') #Negative\n",
    "plt.legend()\n",
    "\n",
    "plt.plot([0.00637062,\n",
    "0.00669765,\n",
    "-0.00370307,\n",
    "0.00565143,\n",
    "0.00807923,\n",
    "0.00528394,\n",
    "0.01857916,\n",
    "0.07073232,\n",
    "0.00445179,\n",
    "0.0124948,\n",
    "0.00728046,\n",
    "0.00728046,\n",
    "0.00737986,\n",
    "0.01575797,\n",
    "0.01545709,\n",
    "0.00601889,\n",
    "0.01376219,\n",
    "0.01699376,\n",
    "0.0089542,\n",
    "0.01276097,\n",
    "0.00595578,\n",
    "0.01751791,\n",
    "0.01055092,\n",
    "0.01075988,\n",
    "0.0134648,\n",
    "0.01340894,\n",
    "0.01433224,\n",
    "0.00866604,\n",
    "0.00084594,\n",
    "0.01010863,\n",
    "0.01003,\n",
    "0.02045,\n",
    "0.00906746,\n",
    "0.00881333,\n",
    "0.00521356,\n",
    "0.00955752], [0.01440924,\n",
    "0.01105455,\n",
    "0.06085067,\n",
    "0.01877255,\n",
    "0.01386357,\n",
    "0.01533985,\n",
    "0.02228057,\n",
    "0.15929973,\n",
    "0.01535981,\n",
    "0.02166354,\n",
    "0.01796548,\n",
    "0.01796548,\n",
    "0.02000368,\n",
    "0.02321055,\n",
    "0.01704064,\n",
    "0.01980853,\n",
    "0.02166573,\n",
    "0.0393901,\n",
    "0.02082907,\n",
    "0.01509436,\n",
    "0.02046781,\n",
    "0.02297852,\n",
    "0.03226986,\n",
    "0.01363604,\n",
    "0.01952442,\n",
    "0.03156138,\n",
    "0.03001645,\n",
    "0.02290594,\n",
    "0.02087034,\n",
    "0.02135233,\n",
    "0.02161374,\n",
    "0.02650036,\n",
    "0.01698329,\n",
    "0.01740446,\n",
    "0.02232833,\n",
    "0.0224823],\"ro\", label= 'Neutral') #Neutral\n",
    " #Neutral\n",
    "plt.legend()    \n",
    "plt.ylabel('mean curvature of eyes_bottom')\n",
    "plt.xlabel('curvature of mouth_bottom')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np; np.random.seed(0)\n",
    "import matplotlib.transforms as transforms\n",
    "\n",
    "year = np.random.choice(np.arange(2006,2017), size=(300) ) \n",
    "values = np.random.rand(300, 3)\n",
    "\n",
    "plt.figure()\n",
    "\n",
    "offset = lambda p: transforms.ScaledTranslation(p/72.,0, plt.gcf().dpi_scale_trans)\n",
    "trans = plt.gca().transData\n",
    "\n",
    "sc1 = plt.scatter(year, values[:,0], c = 'blue', s = 25, transform=trans+offset(-5))\n",
    "plt.scatter(year, values[:,1], c = 'orange', s = 25)\n",
    "plt.scatter(year, values[:,2], c = 'red', s = 25, transform=trans+offset(5))\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "import matplotlib.pyplot as plt\n",
    " \n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.datasets import fetch_lfw_people\n",
    "from sklearn.metrics import classification_report\n",
    "from sklearn.decomposition import PCA\n",
    "from sklearn.neural_network import MLPClassifier\n",
    "\n",
    " \n",
    "# Load data\n",
    "lfw_dataset = fetch_lfw_people(min_faces_per_person=100)\n",
    " \n",
    "_, h, w = lfw_dataset.images.shape\n",
    "X = lfw_dataset.data\n",
    "y = lfw_dataset.target\n",
    "target_names = lfw_dataset.target_names\n",
    " \n",
    "# split into a training and testing set\n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.1"
  },
  "widgets": {
   "state": {},
   "version": "1.1.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
